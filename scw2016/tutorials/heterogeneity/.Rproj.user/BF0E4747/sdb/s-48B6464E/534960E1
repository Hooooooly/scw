{
    "contents" : "---\ntitle: \"Identifying and Characterizing Subpopulations Using Single Cell RNA-seq Data\"\nauthor: Jean Fan\ndate: November 23, 2016\noutput: md_document\n---\n\n```{r, include = FALSE}\nlibrary(knitr)\nopts_chunk$set(\n    warning = FALSE,\n    message = FALSE,\n    fig.path = 'figure/',\n    cache.path = 'cache/',\n    cache = TRUE\n)\n```\n\n# Identifying and Characterizing Subpopulations Using Single Cell RNA-seq Data\n\nIn this session, we will become familiar with a few computational techniques we can use to identify and characterize subpopulations using single cell RNA-seq data. \n\n## Getting started\n\nA single cell dataset from [Camp et al.](http://www.pnas.org/content/112/51/15672) has been pre-prepared for you. The data is provided as a matrix of gene counts, where each column corresponds to a cell and each row a gene.\n\n```{r, 'clean'}\nload('../../data/cd.RData') \n\n# how many genes? how many cells?\ndim(cd)\n# look at snippet of data\ncd[1:5,1:5]\n\n# filter out low-gene cells (often empty wells)\ncd <- cd[, colSums(cd>0)>1.8e3]\n# remove genes that don't have many reads\ncd <- cd[rowSums(cd)>10, ]\n# remove genes that are not seen in a sufficient number of cells\ncd <- cd[rowSums(cd>0)>5, ]\n\n# how many genes and cells after filtering?\ndim(cd)\n\n# transform to make more data normal\nmat <- log10(as.matrix(cd)+1)\n# look at snippet of data\nmat[1:5, 1:5]\n```\n\nIn the original publication, the authors proposed two main subpopulations: neurons and neuroprogenitor cells (NPCs). These labels have also been provided to you as a reference so we can see how different methods perform in recapitulating these labels. \n\n```{r 'sg'}\nload('../../data/sg.RData') \nhead(sg, 5)\n```\n\n# PCA\n\nNote that there are over 10,000 genes that can be used to cluster cells into subpopulations. One fast, easy, and common technique to identify subpopulations is by using dimensionality reduction to summarize the data into 2 dimensions and then visually identify obvious clusters. Principal component analysis (PCA) is a linear dimensionality reduction method.\n\n```{r, 'pca', fig.width=5, fig.height=5}\n# use principal component analysis for dimensionality reduction\nbase.pca <- prcomp(t(mat))\n# visualize in 2D the first two principal components and color by cell type\nplot(base.pca$x[,1], base.pca$x[,2], col=sg, pch=16, main='PCA')\n```\n\n# tSNE\n\nT-embedded stochastic neighbor embedding (tSNE) is a non-linear dimensionality reduction method. Note that in tSNE, the perplexity parameter is an estimate of the number of effective neighbors. Here, we have 224 cells. A perplexity of 10 is suitable. For larger or smaller numbers of cells, you may want to increase the perplexity accordingly.\n\n```{r, 'tsne', fig.width=5, fig.height=5}\nlibrary(Rtsne)\nd <- stats::dist(t(mat))\nset.seed(0) # tsne has some stochastic steps (gradient descent) so need to set random \ntsne_out <- Rtsne(d, is_distance=TRUE, perplexity=10, verbose = TRUE) \nplot(tsne_out$Y, col=sg, pch=16, main='tSNE')\n```\n\nNote with tSNE, your results are stochastic. Change the seed, change your results.\n\n```{r, 'tsne-2', fig.width=5, fig.height=5}\nset.seed(1) # tsne has some stochastic steps (gradient descent) so need to set random \ntsne_out <- Rtsne(d, is_distance=TRUE, perplexity=10, verbose = TRUE) \nplot(tsne_out$Y, col=sg, pch=16, main='tSNE')\n```\n\nStill, we may be wondering what genes and pathways characterize these subpopulation? For that, additional analysis is often needed and dimensionality reduction alone does not provide us with such insight. \n\n# Differential expression analysis\n\nGiven the two clusters we identified previously, we can identify differentially expressed genes between the two groups of single cells using `scde`. \n\n```{r, 'scde'}\nlibrary(scde)\n```\n\nBriefly, `scde` models each cell using a mixture of a negative binomial (NB) distribution (for the amplified/detected transcripts) and low-level Poisson distribution (for the unobserved or background-level signal of genes that failed to amplify or were not detected for other reasons). These models can then be used to identify robustly differentially expressed genes. For more information, please refer to the original manuscript by [Kharchenko et al](http://www.nature.com/nmeth/journal/v11/n7/full/nmeth.2967.html). \n\n```{r, 'knn', eval=FALSE}\n# EVALUATION NOT NEEDED FOR SAKE OF TIME\nknn <- knn.error.models(cd, k = ncol(cd)/4, n.cores = 1, min.count.threshold = 2, min.nonfailed = 5, max.model.plots = 10)\n```\n\n```{r, 'scde-2', fig.width=5, fig.height=5}\n# just load from what we precomputed for you\nload('../../data/knn.RData') \n\n# estimate gene expression prior\nprior <- scde.expression.prior(models = knn, counts = cd, length.out = 400, show.plot = FALSE)\n\n# run differential expression tests on a subset of genes (to save time)\nvi <- c(\"BCL11B\", \"CDH6\", \"CNTNAP2\", \"GRIK3\", \"NEUROD6\", \"RTN1\", \"RUNX1T1\", \"SERINC5\", \"SLC24A2\", \"STMN2\", \"AIF1L\", \"ANP32E\", \"ARID3C\", \"ASPM\", \"ATP1A2\", \"AURKB\", \"AXL\", \"BCAN\", \"BDH2\", \"C12orf48\")\nediff <- scde.expression.difference(knn, cd[vi,], prior, groups = sg, n.cores = 1, verbose = 1)\n\n# top upregulated genes (tail would show top downregulated ones)\nhead(ediff[order(abs(ediff$Z), decreasing = TRUE), ], )\n\n# visualize results for one gene\nscde.test.gene.expression.difference(\"ATP1A2\", knn, cd, prior, groups = sg)\n\n# heatmap\nediff.sig <- ediff[abs(ediff$cZ) > 1.96, ]\nediff.sig.up <- rownames(ediff.sig[order(ediff.sig$cZ, decreasing = TRUE), ])[1:10]\nediff.sig.down <- rownames(ediff.sig[order(ediff.sig$cZ, decreasing = FALSE), ])[1:10]\nheatmap(mat[c(ediff.sig.up, ediff.sig.down),], Rowv=NA, ColSideColors = rainbow(2)[sg],  col=colorRampPalette(c('blue', 'white', 'red'))(100), scale=\"none\")\n```\n\nOnce we have a set of differentially expressed genes, we may use techniques such as gene set enrichment analysis (GSEA) to determine which pathways are differentially up or down regulated. GSEA is not specific to single cell methods and not included in this session but users are encouraged to check out this [light-weight R implementation with tutorials](https://github.com/JEFworks/liger) on their own time. \n\n# Pathway and gene set overdispersion analysis\n\nAlternatively, we may be interested in finer, potentially overlapping/non-binary subpopulations. For example, if we were clustering apples, PCA might separate red apples from green apples, but we may be interested in sweet vs. sour apples, or high fiber apples from low fiber apples. `PAGODA` is a method developed by the Kharchenko lab that enables identification and characterization of subpopulations in a manner that resolves these overlapping aspects of transcriptional heterogeneity. For more information, please refer to the original manuscript by [Fan et al](http://www.nature.com/nmeth/journal/v13/n3/full/nmeth.3734.html). \n\n```{r, 'pagoda', fig.width=5, fig.height=5}\nlibrary(scde)\n\n# again, PAGODA like SCDE relies on error models\nload('../../data/cd.RData') \nload('../../data/knn.RData') \n```\n\n`PAGODA` relies on accurate quantification of excess variance or overdispersion in genes and gene sets in order to cluster cells and identify subpopulations. Accurate quantification of this overdispersion means that we must normalize out expected levels of technical and intrinsic biological noise. Intuitively, lowly-expressed genes are often more prone to drop-out and thus may exhibit large variances simply due to such technical noise.\n\n```{r, 'pagoda-varnorm', eval=FALSE}\n# EVALUATION NOT NEEDED FOR SAKE OF TIME\nvarinfo <- pagoda.varnorm(knn, counts = cd, trim = 3/ncol(cd), max.adj.var = 5, n.cores = 1, plot = TRUE)\n# normalize out sequencing depth as well\nvarinfo <- pagoda.subtract.aspect(varinfo, colSums(cd[, rownames(knn)]>0))\n```\n\n```{r, 'pagoda-varnorm-2'}\n# just load from what we precomputed for you\nload('../../data/varinfo.RData') \n```\n\nWhen assessing for overdispersion in gene sets, we can take advantage of pre-defined pathway gene sets such as GO annotations and look for pathways that exhibit statistically significant excess of coordinated variability. Intuitively, if a pathway is differentially perturbed, we expect all genes within said pathway to be upregulated or downregulated in the same group of cells. In PAGODA, for each gene set, we tested whether the amount of variance explained by the first principal component significantly exceed the background expectation.\n\n```{r, 'pagoda-go', fig.width=5, fig.height=5}\n# load gene sets\nload('../../data/go.env.RData')\n# look at some gene sets\nhead(ls(go.env))\n# look at genes in gene set\nget(\"GO:0000002 mitochondrial genome maintenance\", go.env)\n# filter out gene sets that are too small or too big\ngo.env <- list2env(clean.gos(go.env, min.size=10, max.size=100))\n# how many pathways\nlength(go.env)\n```\n\n```{r, 'pagoda-pwpca', eval=FALSE}\n# EVALUATION NOT NEEDED FOR SAKE OF TIME\n# pathway overdispersion\npwpca <- pagoda.pathway.wPCA(varinfo, go.env, n.components = 1, n.cores = 1)\n```\n\nInstead of relying on pre-defined pathways, we can also test on 'de novo' gene sets whose expression profiles are well-correlated within the given dataset.\n\n```{r, 'pagoda-denovo', eval=FALSE}\n# EVALUATION NOT NEEDED FOR SAKE OF TIME\n# de novo gene sets\nclpca <- pagoda.gene.clusters(varinfo, trim = 7.1/ncol(varinfo$mat), n.clusters = 150, n.cores = 1, plot = FALSE)\n```\n\nTesting these pre-defined pathways and annotated gene sets may take a few minutes so for the sake of time, we will load a pre-computed version.\n\n```{r, 'pagoda-pathway', fig.width=5, fig.height=5}\nload('../../data/pwpca.RData')\nclpca <- NULL # For the sake of time, set to NULL\n```\n\nTaking into consideration both pre-defined pathways and de-novo gene sets, we can see which aspects of heterogeneity are the most overdispersed and base our cell cluster only on the most overdispersed and informative pathways and gene sets.\n\n```{r, 'pagoda-aspect', fig.width=5, fig.height=5}\n# get full info on the top aspects\ndf <- pagoda.top.aspects(pwpca, clpca, z.score = 1.96, return.table = TRUE)\nhead(df)\ntam <- pagoda.top.aspects(pwpca, clpca, z.score = 1.96)\n# determine overall cell clustering\nhc <- pagoda.cluster.cells(tam, varinfo)\n```\n\nBecause many of our annotated pathways and de novo gene sets likely share many genes or exhibit similar patterns of variability, we must reduce such redundancy to come up with a final coherent characterization of subpopulations. \n\n```{r, 'pagoda-tam', fig.width=8, fig.height=5}\n# reduce redundant aspects\ntamr <- pagoda.reduce.loading.redundancy(tam, pwpca, clpca)\ntamr2 <- pagoda.reduce.redundancy(tamr, plot = FALSE)\n# view final result\npagoda.view.aspects(tamr2, cell.clustering = hc, box = TRUE, labCol = NA, margins = c(0.5, 20), col.cols = rbind(sg), top=10)\n```\n\nWe can create an app to further interactively browse the results. A pre-compiled app has been launched for you here: http://pklab.med.harvard.edu/cgi-bin/R/rook/scw.xiaochang/index.html. \n\n```{r, 'pagoda-app', eval=FALSE}\n# compile a browsable app\napp <- make.pagoda.app(tamr2, tam, varinfo, go.env, pwpca, clpca, col.cols = rbind(sg), cell.clustering = hc, title = \"Camp\")\n# show app in the browser (port 1468)\nshow.app(app, \"Camp\", browse = TRUE, port = 1468)  \n```\n\nBased on PAGODA results, we can see the main division between neurons and NPCs but we can also see further heterogeneity not visible by PCA or tSNE alone. In this case, prior knowledge on known marker genes can allow us to better interpret these identified subpopulations as IPCs, RGs, Immature Neurons, and Mature Neurons. \n\n```{r, 'pagoda-marker', fig.width=5, fig.height=5}\n# visualize a few known markers\nmarkers <- c(\n    \"SCN2A\",\"GRIK3\",\"CDH6\",\"NRCAM\",\"SOX11\",\n    \"SLC24A2\", \"SOX4\", \"DCX\", \"TUBB3\",\"MAPT\",\n    \"KHDRBS3\",  \"KHDRBS2\", \"KHDRBS1\", \"RBFOX3\",\n    \"CELF6\", \"CELF5\", \"CELF4\", \"CELF3\", \"CELF2\", \"CELF1\",\n    \"PTBP2\", \"PTBP1\", \"ZFP36L2\",\n    \"HMGN2\", \"PAX6\", \"SFRP1\",\n    \"SOX2\", \"HES1\", \"NOTCH2\", \"CLU\",\"HOPX\",\n    \"MKI67\",\"TPX2\",\n    \"EOMES\", \"NEUROD4\",\"HES6\"\n    )\n# heatmap\nmat <- varinfo$mat[markers,]\nrange(mat)\nmat[mat < -1] <- -1\nmat[mat > 1] <- 1\nheatmap(mat[,hc$labels], Colv=as.dendrogram(hc), Rowv=NA, scale=\"none\", col=colorRampPalette(c(\"blue\", \"white\", \"red\"))(100), ColSideColors=rainbow(2)[sg])\n\n# Alternatively, define more refined subpopulations\nsg2 <- as.factor(cutree(hc, k=4))\nnames(sg2) <- hc$labels\nheatmap(mat[,hc$labels], Colv=as.dendrogram(hc), Rowv=NA, scale=\"none\", col=colorRampPalette(c(\"blue\", \"white\", \"red\"))(100), ColSideColors=rainbow(4)[sg2])\n```\n\n# Pseudo-time trajectory analysis\n\nCells may not always fall into distinct subpopulations. Rather, they may form a continuous gradient along a pseudo-time trajectory. For this type of analysis, we will use `Monocle` from the [Trapnell lab](http://www.nature.com/nbt/journal/v32/n4/full/nbt.2859.html). \n\n```{r, 'monocle', fig.width=5, fig.height=5}\nlibrary(monocle)\n\n# Monocle takes as input fpkms\nload('../../data/fpm.RData')\nexpression.data <- fpm\n\n# create pheno data object \npheno.data.df <- data.frame(type=sg[colnames(fpm)], pagoda=sg2[colnames(fpm)]) \npd <- new('AnnotatedDataFrame', data = pheno.data.df) \n\n# convert data object needed for Monocle\ndata <- newCellDataSet(expression.data, phenoData = pd)\n```\n\nTypically, to order cells by progress, we want to reduce the number of genes analyzed. So we can select for a subset of genes that we believe are important in setting said ordering, such as overdispersed genes. In this example, we will simply choose genes based on prior knowledge. \n\n```{r, 'monocle-2', fig.width=5, fig.height=5}\nordering.genes <- markers # Select genes used for ordering\ndata <- setOrderingFilter(data, ordering.genes) # Set list of genes for ordering\ndata <- reduceDimension(data, use_irlba = FALSE) # Reduce dimensionality\nset.seed(0) # Monocle is also stochastic\ndata <- orderCells(data, num_paths = 2, reverse = FALSE) # Order cells\n\n# Plot trajectory with inferred branches\nplot_spanning_tree(data) \n\n# Compare with previous annotations\nplot_spanning_tree(data, color_by = \"type\") \n\n# Compare with PAGODA annotations\nplot_spanning_tree(data, color_by = \"pagoda\") \n```\n",
    "created" : 1479853490025.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1873381011",
    "id" : "534960E1",
    "lastKnownWriteTime" : 1479926502,
    "path" : "~/Dropbox/jfan/Github/scw/scw2016/tutorials/heterogeneity/heterogeneity.Rmd",
    "project_path" : "heterogeneity.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}