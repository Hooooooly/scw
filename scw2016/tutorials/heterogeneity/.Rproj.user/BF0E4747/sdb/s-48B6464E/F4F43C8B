{
    "contents" : "Identifying and Characterizing Subpopulations Using Single Cell RNA-seq Data\n============================================================================\n\nIn this session, we will become familiar with a few computational\ntechniques we can use to identify and characterize subpopulations using\nsingle cell RNA-seq data.\n\nGetting started\n---------------\n\nA single cell dataset from [Camp et\nal.](http://www.pnas.org/content/112/51/15672) has been pre-prepared for\nyou. The data is provided as a matrix of gene counts, where each column\ncorresponds to a cell and each row a gene.\n\n    load('../../data/cd.RData') \n\n    # how many genes? how many cells?\n    dim(cd)\n\n    ## [1] 23228   224\n\n    # look at snippet of data\n    cd[1:5,1:5]\n\n    ##             SRR2967608 SRR2967609 SRR2967610 SRR2967611 SRR2967612\n    ## 1/2-SBSRNA4          1         18          0          0          0\n    ## A1BG                 0          0          2          0          0\n    ## A1BG-AS1             0          0          0          0          0\n    ## A1CF                 0          0          0          0          0\n    ## A2LD1                0          0          0          0          0\n\n    # filter out low-gene cells (often empty wells)\n    cd <- cd[, colSums(cd>0)>1.8e3]\n    # remove genes that don't have many reads\n    cd <- cd[rowSums(cd)>10, ]\n    # remove genes that are not seen in a sufficient number of cells\n    cd <- cd[rowSums(cd>0)>5, ]\n\n    # how many genes and cells after filtering?\n    dim(cd)\n\n    ## [1] 12453   224\n\n    # transform to make more data normal\n    mat <- log10(as.matrix(cd)+1)\n    # look at snippet of data\n    mat[1:5, 1:5]\n\n    ##             SRR2967608 SRR2967609 SRR2967610 SRR2967611 SRR2967612\n    ## 1/2-SBSRNA4  0.3010300   1.278754  0.0000000          0   0.000000\n    ## A1BG         0.0000000   0.000000  0.4771213          0   0.000000\n    ## A2M          0.0000000   0.000000  0.0000000          0   0.000000\n    ## A2MP1        0.0000000   0.000000  0.0000000          0   0.000000\n    ## AAAS         0.4771213   1.959041  0.0000000          0   1.361728\n\nIn the original publication, the authors proposed two main\nsubpopulations: neurons and neuroprogenitor cells (NPCs). These labels\nhave also been provided to you as a reference so we can see how\ndifferent methods perform in recapitulating these labels.\n\n    load('../../data/sg.RData') \n    head(sg, 5)\n\n    ## SRR2967608 SRR2967609 SRR2967610 SRR2967611 SRR2967612 \n    ##     neuron     neuron     neuron        npc     neuron \n    ## Levels: neuron npc\n\nPCA\n===\n\nNote that there are over 10,000 genes that can be used to cluster cells\ninto subpopulations. One fast, easy, and common technique to identify\nsubpopulations is by using dimensionality reduction to summarize the\ndata into 2 dimensions and then visually identify obvious clusters.\nPrincipal component analysis (PCA) is a linear dimensionality reduction\nmethod.\n\n    # use principal component analysis for dimensionality reduction\n    base.pca <- prcomp(t(mat))\n    # visualize in 2D the first two principal components and color by cell type\n    plot(base.pca$x[,1], base.pca$x[,2], col=sg, pch=16, main='PCA')\n\n![](figure/pca-1.png)<!-- -->\n\ntSNE\n====\n\nT-embedded stochastic neighbor embedding (tSNE) is a non-linear\ndimensionality reduction method. Note that in tSNE, the perplexity\nparameter is an estimate of the number of effective neighbors. Here, we\nhave 224 cells. A perplexity of 10 is suitable. For larger or smaller\nnumbers of cells, you may want to increase the perplexity accordingly.\n\n    library(Rtsne)\n    d <- stats::dist(t(mat))\n    set.seed(0) # tsne has some stochastic steps (gradient descent) so need to set random \n    tsne_out <- Rtsne(d, is_distance=TRUE, perplexity=10, verbose = TRUE) \n\n    ## Read the 224 x 224 data matrix successfully!\n    ## Using no_dims = 2, perplexity = 10.000000, and theta = 0.500000\n    ## Computing input similarities...\n    ## Building tree...\n    ##  - point 0 of 224\n    ## Done in 0.01 seconds (sparsity = 0.243025)!\n    ## Learning embedding...\n    ## Iteration 50: error is 118.973680 (50 iterations in 0.05 seconds)\n    ## Iteration 100: error is 127.558911 (50 iterations in 0.06 seconds)\n    ## Iteration 150: error is 123.943221 (50 iterations in 0.07 seconds)\n    ## Iteration 200: error is 130.050267 (50 iterations in 0.09 seconds)\n    ## Iteration 250: error is 127.913196 (50 iterations in 0.10 seconds)\n    ## Iteration 300: error is 3.617403 (50 iterations in 0.07 seconds)\n    ## Iteration 350: error is 2.286202 (50 iterations in 0.04 seconds)\n    ## Iteration 400: error is 2.190548 (50 iterations in 0.04 seconds)\n    ## Iteration 450: error is 2.133582 (50 iterations in 0.04 seconds)\n    ## Iteration 500: error is 2.086473 (50 iterations in 0.04 seconds)\n    ## Iteration 550: error is 2.060643 (50 iterations in 0.04 seconds)\n    ## Iteration 600: error is 2.031325 (50 iterations in 0.04 seconds)\n    ## Iteration 650: error is 1.983069 (50 iterations in 0.04 seconds)\n    ## Iteration 700: error is 1.846377 (50 iterations in 0.04 seconds)\n    ## Iteration 750: error is 1.827168 (50 iterations in 0.04 seconds)\n    ## Iteration 800: error is 1.825835 (50 iterations in 0.05 seconds)\n    ## Iteration 850: error is 1.825061 (50 iterations in 0.04 seconds)\n    ## Iteration 900: error is 1.825387 (50 iterations in 0.06 seconds)\n    ## Iteration 950: error is 1.824545 (50 iterations in 0.06 seconds)\n    ## Iteration 1000: error is 1.823723 (50 iterations in 0.06 seconds)\n    ## Fitting performed in 1.07 seconds.\n\n    plot(tsne_out$Y, col=sg, pch=16, main='tSNE')\n\n![](figure/tsne-1.png)<!-- -->\n\nNote with tSNE, your results are stochastic. Change the seed, change\nyour results.\n\n    set.seed(1) # tsne has some stochastic steps (gradient descent) so need to set random \n    tsne_out <- Rtsne(d, is_distance=TRUE, perplexity=10, verbose = TRUE) \n\n    ## Read the 224 x 224 data matrix successfully!\n    ## Using no_dims = 2, perplexity = 10.000000, and theta = 0.500000\n    ## Computing input similarities...\n    ## Building tree...\n    ##  - point 0 of 224\n    ## Done in 0.01 seconds (sparsity = 0.243025)!\n    ## Learning embedding...\n    ## Iteration 50: error is 123.486260 (50 iterations in 0.08 seconds)\n    ## Iteration 100: error is 127.644744 (50 iterations in 0.07 seconds)\n    ## Iteration 150: error is 125.135074 (50 iterations in 0.06 seconds)\n    ## Iteration 200: error is 129.868562 (50 iterations in 0.06 seconds)\n    ## Iteration 250: error is 138.279847 (50 iterations in 0.06 seconds)\n    ## Iteration 300: error is 4.395593 (50 iterations in 0.06 seconds)\n    ## Iteration 350: error is 3.569927 (50 iterations in 0.05 seconds)\n    ## Iteration 400: error is 2.725121 (50 iterations in 0.05 seconds)\n    ## Iteration 450: error is 2.243356 (50 iterations in 0.04 seconds)\n    ## Iteration 500: error is 2.204841 (50 iterations in 0.04 seconds)\n    ## Iteration 550: error is 2.168027 (50 iterations in 0.04 seconds)\n    ## Iteration 600: error is 2.136227 (50 iterations in 0.06 seconds)\n    ## Iteration 650: error is 2.094058 (50 iterations in 0.06 seconds)\n    ## Iteration 700: error is 2.045998 (50 iterations in 0.05 seconds)\n    ## Iteration 750: error is 2.039275 (50 iterations in 0.06 seconds)\n    ## Iteration 800: error is 2.028664 (50 iterations in 0.06 seconds)\n    ## Iteration 850: error is 2.007481 (50 iterations in 0.05 seconds)\n    ## Iteration 900: error is 1.976311 (50 iterations in 0.05 seconds)\n    ## Iteration 950: error is 1.926869 (50 iterations in 0.05 seconds)\n    ## Iteration 1000: error is 1.835692 (50 iterations in 0.04 seconds)\n    ## Fitting performed in 1.09 seconds.\n\n    plot(tsne_out$Y, col=sg, pch=16, main='tSNE')\n\n![](figure/tsne-2-1.png)<!-- -->\n\nStill, we may be wondering what genes and pathways characterize these\nsubpopulation? For that, additional analysis is often needed and\ndimensionality reduction alone does not provide us with such insight.\n\nDifferential expression analysis\n================================\n\nGiven the two clusters we identified previously, we can identify\ndifferentially expressed genes between the two groups of single cells\nusing `scde`.\n\n    library(scde)\n\nBriefly, `scde` models each cell using a mixture of a negative binomial\n(NB) distribution (for the amplified/detected transcripts) and low-level\nPoisson distribution (for the unobserved or background-level signal of\ngenes that failed to amplify or were not detected for other reasons).\nThese models can then be used to identify robustly differentially\nexpressed genes. For more information, please refer to the original\nmanuscript by [Kharchenko et\nal](http://www.nature.com/nmeth/journal/v11/n7/full/nmeth.2967.html).\n\n    # EVALUATION NOT NEEDED FOR SAKE OF TIME\n    knn <- knn.error.models(cd, k = ncol(cd)/4, n.cores = 1, min.count.threshold = 2, min.nonfailed = 5, max.model.plots = 10)\n\n    # just load from what we precomputed for you\n    load('../../data/knn.RData') \n\n    # estimate gene expression prior\n    prior <- scde.expression.prior(models = knn, counts = cd, length.out = 400, show.plot = FALSE)\n\n    # run differential expression tests on a subset of genes (to save time)\n    vi <- c(\"BCL11B\", \"CDH6\", \"CNTNAP2\", \"GRIK3\", \"NEUROD6\", \"RTN1\", \"RUNX1T1\", \"SERINC5\", \"SLC24A2\", \"STMN2\", \"AIF1L\", \"ANP32E\", \"ARID3C\", \"ASPM\", \"ATP1A2\", \"AURKB\", \"AXL\", \"BCAN\", \"BDH2\", \"C12orf48\")\n    ediff <- scde.expression.difference(knn, cd[vi,], prior, groups = sg, n.cores = 1, verbose = 1)\n\n    ## comparing groups:\n    ## \n    ## neuron    npc \n    ##    165     59 \n    ## calculating difference posterior\n    ## summarizing differences\n\n    # top upregulated genes (tail would show top downregulated ones)\n    head(ediff[order(abs(ediff$Z), decreasing = TRUE), ], )\n\n    ##                 lb       mle        ub        ce         Z        cZ\n    ## ATP1A2   -9.377059 -8.554510 -7.485196 -7.485196 -7.160847 -7.155924\n    ## AXL     -10.035099 -9.500442 -2.837794 -2.837794 -7.160847 -7.155924\n    ## BCAN     -8.019853 -6.991667 -5.511079 -5.511079 -7.160847 -7.155924\n    ## STMN2     2.714412  3.536961  4.400637  2.714412  7.160813  7.155924\n    ## RUNX1T1   2.220882  2.837794  6.210245  2.220882  7.160813  7.155924\n    ## RTN1      2.303137  3.084559  6.169118  2.303137  7.160813  7.155924\n\n    # visualize results for one gene\n    scde.test.gene.expression.difference(\"ATP1A2\", knn, cd, prior, groups = sg)\n\n![](figure/scde-2-1.png)<!-- -->\n\n    ##               lb       mle        ub        ce         Z        cZ\n    ## ATP1A2 -9.377059 -8.677893 -7.567451 -7.567451 -7.160847 -7.160847\n\n    # heatmap\n    ediff.sig <- ediff[abs(ediff$cZ) > 1.96, ]\n    ediff.sig.up <- rownames(ediff.sig[order(ediff.sig$cZ, decreasing = TRUE), ])[1:10]\n    ediff.sig.down <- rownames(ediff.sig[order(ediff.sig$cZ, decreasing = FALSE), ])[1:10]\n    heatmap(mat[c(ediff.sig.up, ediff.sig.down),], Rowv=NA, ColSideColors = rainbow(2)[sg],  col=colorRampPalette(c('blue', 'white', 'red'))(100), scale=\"none\")\n\n![](figure/scde-2-2.png)<!-- -->\n\nOnce we have a set of differentially expressed genes, we may use\ntechniques such as gene set enrichment analysis (GSEA) to determine\nwhich pathways are differentially up or down regulated. GSEA is not\nspecific to single cell methods and not included in this session but\nusers are encouraged to check out this [light-weight R implementation\nwith tutorials](https://github.com/JEFworks/liger) on their own time.\n\nPathway and gene set overdispersion analysis\n============================================\n\nAlternatively, we may be interested in finer, potentially\noverlapping/non-binary subpopulations. For example, if we were\nclustering apples, PCA might separate red apples from green apples, but\nwe may be interested in sweet vs. sour apples, or high fiber apples from\nlow fiber apples. `PAGODA` is a method developed by the Kharchenko lab\nthat enables identification and characterization of subpopulations in a\nmanner that resolves these overlapping aspects of transcriptional\nheterogeneity. For more information, please refer to the original\nmanuscript by [Fan et\nal](http://www.nature.com/nmeth/journal/v13/n3/full/nmeth.3734.html).\n\n    library(scde)\n\n    # again, PAGODA like SCDE relies on error models\n    load('../../data/cd.RData') \n    load('../../data/knn.RData') \n\n`PAGODA` relies on accurate quantification of excess variance or\noverdispersion in genes and gene sets in order to cluster cells and\nidentify subpopulations. Accurate quantification of this overdispersion\nmeans that we must normalize out expected levels of technical and\nintrinsic biological noise. Intuitively, lowly-expressed genes are often\nmore prone to drop-out and thus may exhibit large variances simply due\nto such technical noise.\n\n    # EVALUATION NOT NEEDED FOR SAKE OF TIME\n    varinfo <- pagoda.varnorm(knn, counts = cd, trim = 3/ncol(cd), max.adj.var = 5, n.cores = 1, plot = TRUE)\n    # normalize out sequencing depth as well\n    varinfo <- pagoda.subtract.aspect(varinfo, colSums(cd[, rownames(knn)]>0))\n\n    # just load from what we precomputed for you\n    load('../../data/varinfo.RData') \n\nWhen assessing for overdispersion in gene sets, we can take advantage of\npre-defined pathway gene sets such as GO annotations and look for\npathways that exhibit statistically significant excess of coordinated\nvariability. Intuitively, if a pathway is differentially perturbed, we\nexpect all genes within said pathway to be upregulated or downregulated\nin the same group of cells. In PAGODA, for each gene set, we tested\nwhether the amount of variance explained by the first principal\ncomponent significantly exceed the background expectation.\n\n    # load gene sets\n    load('../../data/go.env.RData')\n    # look at some gene sets\n    head(ls(go.env))\n\n    ## [1] \"GO:0000002 mitochondrial genome maintenance\"            \n    ## [2] \"GO:0000012 single strand break repair\"                  \n    ## [3] \"GO:0000018 regulation of DNA recombination\"             \n    ## [4] \"GO:0000030 mannosyltransferase activity\"                \n    ## [5] \"GO:0000038 very long-chain fatty acid metabolic process\"\n    ## [6] \"GO:0000041 transition metal ion transport\"\n\n    # look at genes in gene set\n    get(\"GO:0000002 mitochondrial genome maintenance\", go.env)\n\n    ## [1] \"AKT3\"    \"C10orf2\" \"DNA2\"    \"MEF2A\"   \"MPV17\"   \"PID1\"    \"SLC25A4\"\n    ## [8] \"TYMP\"\n\n    # filter out gene sets that are too small or too big\n    go.env <- list2env(clean.gos(go.env, min.size=10, max.size=100))\n    # how many pathways\n    length(go.env)\n\n    ## [1] 3225\n\n    # EVALUATION NOT NEEDED FOR SAKE OF TIME\n    # pathway overdispersion\n    pwpca <- pagoda.pathway.wPCA(varinfo, go.env, n.components = 1, n.cores = 1)\n\nInstead of relying on pre-defined pathways, we can also test on 'de\nnovo' gene sets whose expression profiles are well-correlated within the\ngiven dataset.\n\n    # EVALUATION NOT NEEDED FOR SAKE OF TIME\n    # de novo gene sets\n    clpca <- pagoda.gene.clusters(varinfo, trim = 7.1/ncol(varinfo$mat), n.clusters = 150, n.cores = 1, plot = FALSE)\n\nTesting these pre-defined pathways and annotated gene sets may take a\nfew minutes so for the sake of time, we will load a pre-computed\nversion.\n\n    load('../../data/pwpca.RData')\n    clpca <- NULL # For the sake of time, set to NULL\n\nTaking into consideration both pre-defined pathways and de-novo gene\nsets, we can see which aspects of heterogeneity are the most\noverdispersed and base our cell cluster only on the most overdispersed\nand informative pathways and gene sets.\n\n    # get full info on the top aspects\n    df <- pagoda.top.aspects(pwpca, clpca, z.score = 1.96, return.table = TRUE)\n    head(df)\n\n    ##                                                    name npc   n    score\n    ## 78  GO:0000779 condensed chromosome, centromeric region   1  24 4.689757\n    ## 743                   GO:0007059 chromosome segregation   1  97 4.632092\n    ## 17                           GO:0000087 mitotic M phase   1 198 4.606980\n    ## 77          GO:0000777 condensed chromosome kinetochore   1  20 4.529740\n    ## 746                 GO:0007067 mitotic nuclear division   1 189 4.506514\n    ## 47                          GO:0000280 nuclear division   1 189 4.506514\n    ##            z    adj.z sh.z adj.sh.z\n    ## 78  22.64153 22.44831   NA       NA\n    ## 743 33.07666 32.90101   NA       NA\n    ## 17  40.87730 40.71825   NA       NA\n    ## 77  20.85181 20.65224   NA       NA\n    ## 746 39.43297 39.28004   NA       NA\n    ## 47  39.43297 39.28004   NA       NA\n\n    tam <- pagoda.top.aspects(pwpca, clpca, z.score = 1.96)\n    # determine overall cell clustering\n    hc <- pagoda.cluster.cells(tam, varinfo)\n\nBecause many of our annotated pathways and de novo gene sets likely\nshare many genes or exhibit similar patterns of variability, we must\nreduce such redundancy to come up with a final coherent characterization\nof subpopulations.\n\n    # reduce redundant aspects\n    tamr <- pagoda.reduce.loading.redundancy(tam, pwpca, clpca)\n    tamr2 <- pagoda.reduce.redundancy(tamr, plot = FALSE)\n    # view final result\n    pagoda.view.aspects(tamr2, cell.clustering = hc, box = TRUE, labCol = NA, margins = c(0.5, 20), col.cols = rbind(sg), top=10)\n\n![](figure/pagoda-tam-1.png)<!-- -->\n\nWe can create an app to further interactively browse the results. A\npre-compiled app has been launched for you here:\n<http://pklab.med.harvard.edu/cgi-bin/R/rook/scw.xiaochang/index.html>.\n\n    # compile a browsable app\n    app <- make.pagoda.app(tamr2, tam, varinfo, go.env, pwpca, clpca, col.cols = rbind(sg), cell.clustering = hc, title = \"Camp\")\n    # show app in the browser (port 1468)\n    show.app(app, \"Camp\", browse = TRUE, port = 1468)  \n\nBased on PAGODA results, we can see the main division between neurons\nand NPCs but we can also see further heterogeneity not visible by PCA or\ntSNE alone. In this case, prior knowledge on known marker genes can\nallow us to better interpret these identified subpopulations as IPCs,\nRGs, Immature Neurons, and Mature Neurons.\n\n    # visualize a few known markers\n    markers <- c(\n        \"SCN2A\",\"GRIK3\",\"CDH6\",\"NRCAM\",\"SOX11\",\n        \"SLC24A2\", \"SOX4\", \"DCX\", \"TUBB3\",\"MAPT\",\n        \"KHDRBS3\",  \"KHDRBS2\", \"KHDRBS1\", \"RBFOX3\",\n        \"CELF6\", \"CELF5\", \"CELF4\", \"CELF3\", \"CELF2\", \"CELF1\",\n        \"PTBP2\", \"PTBP1\", \"ZFP36L2\",\n        \"HMGN2\", \"PAX6\", \"SFRP1\",\n        \"SOX2\", \"HES1\", \"NOTCH2\", \"CLU\",\"HOPX\",\n        \"MKI67\",\"TPX2\",\n        \"EOMES\", \"NEUROD4\",\"HES6\"\n        )\n    # heatmap\n    mat <- varinfo$mat[markers,]\n    range(mat)\n\n    ## [1] -4.346477  3.805928\n\n    mat[mat < -1] <- -1\n    mat[mat > 1] <- 1\n    heatmap(mat[,hc$labels], Colv=as.dendrogram(hc), Rowv=NA, scale=\"none\", col=colorRampPalette(c(\"blue\", \"white\", \"red\"))(100), ColSideColors=rainbow(2)[sg])\n\n![](figure/pagoda-marker-1.png)<!-- -->\n\n    # Alternatively, define more refined subpopulations\n    sg2 <- as.factor(cutree(hc, k=4))\n    names(sg2) <- hc$labels\n    heatmap(mat[,hc$labels], Colv=as.dendrogram(hc), Rowv=NA, scale=\"none\", col=colorRampPalette(c(\"blue\", \"white\", \"red\"))(100), ColSideColors=rainbow(4)[sg2])\n\n![](figure/pagoda-marker-2.png)<!-- -->\n\nPseudo-time trajectory analysis\n===============================\n\nCells may not always fall into distinct subpopulations. Rather, they may\nform a continuous gradient along a pseudo-time trajectory. For this type\nof analysis, we will use `Monocle` from the [Trapnell\nlab](http://www.nature.com/nbt/journal/v32/n4/full/nbt.2859.html).\n\n    library(monocle)\n\n    # Monocle takes as input fpkms\n    load('../../data/fpm.RData')\n    expression.data <- fpm\n\n    # create pheno data object \n    pheno.data.df <- data.frame(type=sg[colnames(fpm)], pagoda=sg2[colnames(fpm)]) \n    pd <- new('AnnotatedDataFrame', data = pheno.data.df) \n\n    # convert data object needed for Monocle\n    data <- newCellDataSet(expression.data, phenoData = pd)\n\nTypically, to order cells by progress, we want to reduce the number of\ngenes analyzed. So we can select for a subset of genes that we believe\nare important in setting said ordering, such as overdispersed genes. In\nthis example, we will simply choose genes based on prior knowledge.\n\n    ordering.genes <- markers # Select genes used for ordering\n    data <- setOrderingFilter(data, ordering.genes) # Set list of genes for ordering\n    data <- reduceDimension(data, use_irlba = FALSE) # Reduce dimensionality\n    set.seed(0) # Monocle is also stochastic\n    data <- orderCells(data, num_paths = 2, reverse = FALSE) # Order cells\n\n    # Plot trajectory with inferred branches\n    plot_spanning_tree(data) \n\n![](figure/monocle-2-1.png)<!-- -->\n\n    # Compare with previous annotations\n    plot_spanning_tree(data, color_by = \"type\") \n\n![](figure/monocle-2-2.png)<!-- -->\n\n    # Compare with PAGODA annotations\n    plot_spanning_tree(data, color_by = \"pagoda\") \n\n![](figure/monocle-2-3.png)<!-- -->\n",
    "created" : 1479926470182.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2395516648",
    "id" : "F4F43C8B",
    "lastKnownWriteTime" : 1479926582,
    "path" : "~/Dropbox/jfan/Github/scw/scw2016/tutorials/heterogeneity/heterogeneity.md",
    "project_path" : "heterogeneity.md",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "markdown"
}